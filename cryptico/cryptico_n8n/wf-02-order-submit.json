{
  "name": "Cryptico-ATM-02-Order-Submit",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "order/submit",
        "authentication": "headerAuth",
        "responseMode": "responseNode",
        "options": {
          "rawBody": false
        }
      },
      "id": "01-trigger-webhook",
      "name": "01-trigger-webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [260, 300],
      "webhookId": "cryptico-order-submit"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Input validation with JSON Schema\nconst input = $input.first().json;\nconst errors = [];\n\n// Required fields validation\nconst requiredFields = [\n  { field: 'crypto', type: 'string', values: ['USDT', 'USDC', 'BNB', 'MATIC'] },\n  { field: 'network', type: 'string', values: ['TRC-20', 'BEP-20', 'ERC-20', 'POLYGON'] },\n  { field: 'amountMYR', type: 'number', min: 50, max: 10000 },\n  { field: 'customerName', type: 'string', minLength: 2 },\n  { field: 'contactType', type: 'string', values: ['telegram', 'email'] },\n  { field: 'contact', type: 'string', minLength: 3 },\n  { field: 'walletAddress', type: 'string', minLength: 20 },\n  { field: 'rateLockTimestamp', type: 'number' }\n];\n\nfor (const req of requiredFields) {\n  const value = input[req.field];\n  \n  if (value === undefined || value === null || value === '') {\n    errors.push(`Missing required field: ${req.field}`);\n    continue;\n  }\n  \n  if (req.type === 'string' && typeof value !== 'string') {\n    errors.push(`${req.field} must be a string`);\n  } else if (req.type === 'number' && typeof value !== 'number') {\n    errors.push(`${req.field} must be a number`);\n  }\n  \n  if (req.values && !req.values.includes(value)) {\n    errors.push(`${req.field} must be one of: ${req.values.join(', ')}`);\n  }\n  \n  if (req.min && value < req.min) {\n    errors.push(`${req.field} must be at least ${req.min}`);\n  }\n  \n  if (req.max && value > req.max) {\n    errors.push(`${req.field} must be at most ${req.max}`);\n  }\n  \n  if (req.minLength && typeof value === 'string' && value.length < req.minLength) {\n    errors.push(`${req.field} must be at least ${req.minLength} characters`);\n  }\n}\n\n// Wallet address validation based on network\nconst walletValidation = {\n  'TRC-20': { prefix: 'T', length: 34 },\n  'BEP-20': { prefix: '0x', length: 42, regex: /^0x[a-fA-F0-9]{40}$/ },\n  'ERC-20': { prefix: '0x', length: 42, regex: /^0x[a-fA-F0-9]{40}$/ },\n  'POLYGON': { prefix: '0x', length: 42, regex: /^0x[a-fA-F0-9]{40}$/ }\n};\n\nif (input.network && input.walletAddress) {\n  const validation = walletValidation[input.network];\n  if (validation) {\n    if (!input.walletAddress.startsWith(validation.prefix)) {\n      errors.push(`Wallet address for ${input.network} must start with ${validation.prefix}`);\n    }\n    if (input.walletAddress.length !== validation.length) {\n      errors.push(`Wallet address for ${input.network} must be ${validation.length} characters`);\n    }\n    if (validation.regex && !validation.regex.test(input.walletAddress)) {\n      errors.push(`Invalid wallet address format for ${input.network}`);\n    }\n  }\n}\n\n// Network compatibility check\nconst cryptoNetworks = {\n  'USDT': ['TRC-20', 'BEP-20', 'ERC-20', 'POLYGON'],\n  'USDC': ['TRC-20', 'BEP-20', 'ERC-20', 'POLYGON'],\n  'BNB': ['BEP-20'],\n  'MATIC': ['POLYGON', 'ERC-20']\n};\n\nif (input.crypto && input.network) {\n  const validNetworks = cryptoNetworks[input.crypto];\n  if (validNetworks && !validNetworks.includes(input.network)) {\n    errors.push(`${input.crypto} is not available on ${input.network}. Valid networks: ${validNetworks.join(', ')}`);\n  }\n}\n\nreturn [{\n  json: {\n    ...input,\n    isValid: errors.length === 0,\n    validationErrors: errors,\n    receivedAt: new Date().toISOString()\n  }\n}];"
      },
      "id": "05-validate-input",
      "name": "05-validate-input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [480, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isValid }}",
              "value2": true
            }
          ]
        }
      },
      "id": "06-validation-gate",
      "name": "06-validation-gate",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [700, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Check if rate lock is still valid (5-minute window)\nconst input = $input.first().json;\nconst RATE_LOCK_DURATION_MS = (Number($env.RATE_LOCK_DURATION_SECONDS) || 300) * 1000;\n\nconst now = Date.now();\nconst lockTimestamp = input.rateLockTimestamp;\nconst lockExpiry = lockTimestamp + RATE_LOCK_DURATION_MS;\nconst isLockValid = now <= lockExpiry;\nconst remainingSeconds = Math.max(0, Math.floor((lockExpiry - now) / 1000));\n\nreturn [{\n  json: {\n    ...input,\n    rateLockValid: isLockValid,\n    rateLockExpiry: new Date(lockExpiry).toISOString(),\n    rateLockRemainingSeconds: remainingSeconds\n  }\n}];"
      },
      "id": "10-check-ratelock",
      "name": "10-check-ratelock",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [920, 200]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.rateLockValid }}",
              "value2": true
            }
          ]
        }
      },
      "id": "11-ratelock-gate",
      "name": "11-ratelock-gate",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1140, 200]
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "crypto_prices",
        "filters": {
          "conditions": [
            {
              "keyName": "symbol",
              "condition": "equals",
              "keyValue": "={{ $json.crypto }}"
            }
          ]
        },
        "returnAll": false,
        "limit": 1
      },
      "id": "15-fetch-rate",
      "name": "15-fetch-rate",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1360, 100],
      "credentials": {
        "supabaseApi": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase API"
        }
      }
    },
    {
      "parameters": {
        "mode": "combineBySql",
        "sql": "SELECT \n  input.*,\n  price.rate_with_markup as currentRate,\n  price.price_myr as baseRate,\n  price.updated_at as rateUpdatedAt\nFROM input\nCROSS JOIN price"
      },
      "id": "16-merge-rate",
      "name": "16-merge-rate",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [1580, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Generate order and calculate crypto amount\nconst input = $input.first().json;\n\n// Network fees (MYR)\nconst NETWORK_FEES = {\n  'TRC-20': Number($env.FEE_TRC20) || 1.00,\n  'BEP-20': Number($env.FEE_BEP20) || 2.50,\n  'ERC-20': Number($env.FEE_ERC20) || 15.00,\n  'POLYGON': Number($env.FEE_POLYGON) || 0.50\n};\n\nconst networkFee = NETWORK_FEES[input.network] || 0;\nconst amountAfterFee = input.amountMYR - networkFee;\nconst cryptoAmount = amountAfterFee / input.currentRate;\n\n// Generate unique order ID: CK + timestamp_base36 + random\nconst orderId = 'CK' + Date.now().toString(36).toUpperCase() + \n               Math.random().toString(36).substring(2, 5).toUpperCase();\n\n// Generate idempotency key\nconst idempotencyKey = require('crypto')\n  .createHash('sha256')\n  .update(`${orderId}-${input.walletAddress}-${input.amountMYR}`)\n  .digest('hex')\n  .substring(0, 32);\n\nconst now = new Date().toISOString();\n\nreturn [{\n  json: {\n    // Order data for database\n    order: {\n      id: orderId,\n      idempotency_key: idempotencyKey,\n      crypto: input.crypto,\n      network: input.network,\n      amount_myr: input.amountMYR,\n      amount_crypto: cryptoAmount,\n      network_fee: networkFee,\n      rate: input.currentRate,\n      base_rate: input.baseRate,\n      customer_name: input.customerName,\n      customer_contact_type: input.contactType,\n      customer_contact: input.contact,\n      wallet_address: input.walletAddress,\n      payment_ref: input.paymentRef || null,\n      has_proof_image: !!input.proofImageBase64,\n      status: 'pending',\n      created_at: now,\n      updated_at: now,\n      kiosk_id: input.kioskId || 'default'\n    },\n    // Original input for reference\n    input: input,\n    // Proof image if provided\n    proofImageBase64: input.proofImageBase64 || null\n  }\n}];"
      },
      "id": "20-generate-order",
      "name": "20-generate-order",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1800, 100]
    },
    {
      "parameters": {
        "operation": "create",
        "tableId": "orders",
        "dataToSend": "defineBelow",
        "fieldsUi": {
          "fieldValues": [
            { "fieldName": "id", "fieldValue": "={{ $json.order.id }}" },
            { "fieldName": "idempotency_key", "fieldValue": "={{ $json.order.idempotency_key }}" },
            { "fieldName": "crypto", "fieldValue": "={{ $json.order.crypto }}" },
            { "fieldName": "network", "fieldValue": "={{ $json.order.network }}" },
            { "fieldName": "amount_myr", "fieldValue": "={{ $json.order.amount_myr }}" },
            { "fieldName": "amount_crypto", "fieldValue": "={{ $json.order.amount_crypto }}" },
            { "fieldName": "network_fee", "fieldValue": "={{ $json.order.network_fee }}" },
            { "fieldName": "rate", "fieldValue": "={{ $json.order.rate }}" },
            { "fieldName": "base_rate", "fieldValue": "={{ $json.order.base_rate }}" },
            { "fieldName": "customer_name", "fieldValue": "={{ $json.order.customer_name }}" },
            { "fieldName": "customer_contact_type", "fieldValue": "={{ $json.order.customer_contact_type }}" },
            { "fieldName": "customer_contact", "fieldValue": "={{ $json.order.customer_contact }}" },
            { "fieldName": "wallet_address", "fieldValue": "={{ $json.order.wallet_address }}" },
            { "fieldName": "payment_ref", "fieldValue": "={{ $json.order.payment_ref }}" },
            { "fieldName": "has_proof_image", "fieldValue": "={{ $json.order.has_proof_image }}" },
            { "fieldName": "status", "fieldValue": "={{ $json.order.status }}" },
            { "fieldName": "kiosk_id", "fieldValue": "={{ $json.order.kiosk_id }}" }
          ]
        }
      },
      "id": "25-insert-order",
      "name": "25-insert-order",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [2020, 100],
      "credentials": {
        "supabaseApi": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase API"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Format Telegram notification message\nconst input = $input.first().json;\nconst order = input.order;\n\nconst CRYPTO_ICONS = {\n  'USDT': 'üíµ',\n  'USDC': 'üîµ',\n  'BNB': 'üü°',\n  'MATIC': 'üü£'\n};\n\nconst formatMYR = (amount) => `RM ${Number(amount).toFixed(2)}`;\nconst formatCrypto = (amount) => Number(amount).toFixed(4);\n\nconst message = `\nüîî <b>NEW CRYPTO ORDER</b>\n\nüìã <b>Order ID:</b> <code>${order.id}</code>\nüí∞ <b>Amount Paid:</b> ${formatMYR(order.amount_myr)}\nü™ô <b>Crypto:</b> ${CRYPTO_ICONS[order.crypto] || 'ü™ô'} ${formatCrypto(order.amount_crypto)} ${order.crypto}\nüìç <b>Network:</b> ${order.network}\nüí∏ <b>Network Fee:</b> ${formatMYR(order.network_fee)}\nüìä <b>Rate:</b> 1 ${order.crypto} = ${formatMYR(order.rate)}\n\nüë§ <b>Customer:</b>\n‚îú Name: ${order.customer_name}\n‚îú ${order.customer_contact_type === 'telegram' ? 'Telegram' : 'Email'}: ${order.customer_contact}\n‚îî Wallet: <code>${order.wallet_address}</code>\n\nüí≥ <b>Payment Ref:</b> ${order.payment_ref || 'Screenshot attached'}\nüìÖ <b>Time:</b> ${new Date(order.created_at).toLocaleString('en-MY', { dateStyle: 'medium', timeStyle: 'short' })}\nüèß <b>Kiosk:</b> ${order.kiosk_id}\n\n‚è≥ <b>Status:</b> Awaiting verification\n`.trim();\n\nreturn [{\n  json: {\n    ...input,\n    telegramMessage: message\n  }\n}];"
      },
      "id": "30-format-telegram",
      "name": "30-format-telegram",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2240, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.telegram.org/bot{{ $env.TELEGRAM_BOT_TOKEN }}/sendMessage",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"chat_id\": \"{{ $env.TELEGRAM_CHAT_ID }}\",\n  \"text\": {{ JSON.stringify($json.telegramMessage) }},\n  \"parse_mode\": \"HTML\",\n  \"reply_markup\": {\n    \"inline_keyboard\": [\n      [\n        { \"text\": \"‚úÖ Approve\", \"callback_data\": \"approve_{{ $json.order.id }}\" },\n        { \"text\": \"‚ùå Reject\", \"callback_data\": \"reject_{{ $json.order.id }}\" }\n      ]\n    ]\n  }\n}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "35-send-telegram",
      "name": "35-send-telegram",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2460, 100]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.proofImageBase64 !== null && $json.proofImageBase64 !== '' }}",
              "value2": true
            }
          ]
        }
      },
      "id": "40-check-proof-image",
      "name": "40-check-proof-image",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2680, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.telegram.org/bot{{ $env.TELEGRAM_BOT_TOKEN }}/sendPhoto",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "chat_id",
              "value": "={{ $env.TELEGRAM_CHAT_ID }}"
            },
            {
              "name": "caption",
              "value": "=üì∑ Payment proof for order <code>{{ $json.order.id }}</code>"
            },
            {
              "name": "parse_mode",
              "value": "HTML"
            },
            {
              "parameterType": "formBinaryData",
              "name": "photo",
              "inputDataFieldName": "proofImage"
            }
          ]
        },
        "options": {}
      },
      "id": "45-send-proof-image",
      "name": "45-send-proof-image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2900, 0],
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "id": "50-merge-paths",
      "name": "50-merge-paths",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [3120, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Prepare success response\nconst input = $input.first().json;\nconst order = input.order;\n\nreturn [{\n  json: {\n    ok: true,\n    orderId: order.id,\n    status: 'pending',\n    crypto: order.crypto,\n    network: order.network,\n    amountMYR: order.amount_myr,\n    amountCrypto: order.amount_crypto,\n    rate: order.rate,\n    networkFee: order.network_fee,\n    estimatedDelivery: '15-30 minutes after approval',\n    message: `Order ${order.id} submitted successfully. You will be notified when your order is processed.`,\n    trackingUrl: `/order/lookup/${order.id}`\n  }\n}];"
      },
      "id": "55-format-response",
      "name": "55-format-response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3340, 100]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 201,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "60-reply-success",
      "name": "60-reply-success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3560, 100]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"ok\": false,\n  \"error_code\": \"VALIDATION_ERROR\",\n  \"message\": \"Request validation failed\",\n  \"errors\": {{ JSON.stringify($json.validationErrors) }},\n  \"context\": {\n    \"node\": \"05-validate-input\",\n    \"receivedAt\": \"{{ $json.receivedAt }}\"\n  }\n}",
        "options": {
          "responseCode": 400
        }
      },
      "id": "99-reply-validation-error",
      "name": "99-reply-validation-error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [920, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"ok\": false,\n  \"error_code\": \"RATE_LOCK_EXPIRED\",\n  \"message\": \"Rate lock has expired. Please restart your transaction.\",\n  \"expiredAt\": \"{{ $json.rateLockExpiry }}\",\n  \"context\": {\n    \"node\": \"10-check-ratelock\"\n  }\n}",
        "options": {
          "responseCode": 409
        }
      },
      "id": "99-reply-ratelock-error",
      "name": "99-reply-ratelock-error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1360, 300]
    }
  ],
  "connections": {
    "01-trigger-webhook": {
      "main": [
        [
          {
            "node": "05-validate-input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "05-validate-input": {
      "main": [
        [
          {
            "node": "06-validation-gate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "06-validation-gate": {
      "main": [
        [
          {
            "node": "10-check-ratelock",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "99-reply-validation-error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "10-check-ratelock": {
      "main": [
        [
          {
            "node": "11-ratelock-gate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "11-ratelock-gate": {
      "main": [
        [
          {
            "node": "15-fetch-rate",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "99-reply-ratelock-error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "15-fetch-rate": {
      "main": [
        [
          {
            "node": "16-merge-rate",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "11-ratelock-gate": {
      "main": [
        [
          {
            "node": "16-merge-rate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "16-merge-rate": {
      "main": [
        [
          {
            "node": "20-generate-order",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "20-generate-order": {
      "main": [
        [
          {
            "node": "25-insert-order",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "25-insert-order": {
      "main": [
        [
          {
            "node": "30-format-telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "30-format-telegram": {
      "main": [
        [
          {
            "node": "35-send-telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "35-send-telegram": {
      "main": [
        [
          {
            "node": "40-check-proof-image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "40-check-proof-image": {
      "main": [
        [
          {
            "node": "45-send-proof-image",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "50-merge-paths",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "45-send-proof-image": {
      "main": [
        [
          {
            "node": "50-merge-paths",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "50-merge-paths": {
      "main": [
        [
          {
            "node": "55-format-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "55-format-response": {
      "main": [
        [
          {
            "node": "60-reply-success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveExecutionProgress": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "Cryptico-ATM-07-Error-Handler"
  },
  "staticData": null,
  "tags": [
    { "name": "cryptico-atm" },
    { "name": "order-submit" }
  ],
  "pinData": {},
  "versionId": "1.0.0"
}
