{
  "name": "Cryptico-ATM-02-Order-Submit",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "order/submit",
        "authentication": "headerAuth",
        "responseMode": "responseNode",
        "options": { "rawBody": false }
      },
      "id": "01-trigger-webhook",
      "name": "01-trigger-webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [260, 300],
      "webhookId": "cryptico-order-submit",
      "credentials": { "httpHeaderAuth": { "id": "HEADER_AUTH_CREDENTIAL_ID", "name": "Cryptico API Key" } }
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const input = $input.first().json.body || $input.first().json;\nconst errors = [];\n\nconst requiredFields = [\n  { field: 'crypto', type: 'string', values: ['USDT', 'USDC', 'BNB', 'MATIC'] },\n  { field: 'network', type: 'string', values: ['TRC-20', 'BEP-20', 'ERC-20', 'POLYGON'] },\n  { field: 'amountMYR', type: 'number', min: 50, max: 10000 },\n  { field: 'customerName', type: 'string', minLength: 2 },\n  { field: 'contactType', type: 'string', values: ['telegram', 'email'] },\n  { field: 'contact', type: 'string', minLength: 3 },\n  { field: 'walletAddress', type: 'string', minLength: 20 },\n  { field: 'rateLockTimestamp', type: 'number' }\n];\n\nfor (const req of requiredFields) {\n  const value = input[req.field];\n  if (value === undefined || value === null || value === '') {\n    errors.push(`Missing required field: ${req.field}`);\n    continue;\n  }\n  if (req.type === 'string' && typeof value !== 'string') errors.push(`${req.field} must be a string`);\n  else if (req.type === 'number' && typeof value !== 'number') errors.push(`${req.field} must be a number`);\n  if (req.values && !req.values.includes(value)) errors.push(`${req.field} must be one of: ${req.values.join(', ')}`);\n  if (req.min && value < req.min) errors.push(`${req.field} must be at least ${req.min}`);\n  if (req.max && value > req.max) errors.push(`${req.field} must be at most ${req.max}`);\n  if (req.minLength && typeof value === 'string' && value.length < req.minLength) errors.push(`${req.field} must be at least ${req.minLength} characters`);\n}\n\nconst walletValidation = {\n  'TRC-20': { prefix: 'T', length: 34 },\n  'BEP-20': { prefix: '0x', length: 42, regex: /^0x[a-fA-F0-9]{40}$/ },\n  'ERC-20': { prefix: '0x', length: 42, regex: /^0x[a-fA-F0-9]{40}$/ },\n  'POLYGON': { prefix: '0x', length: 42, regex: /^0x[a-fA-F0-9]{40}$/ }\n};\n\nif (input.network && input.walletAddress) {\n  const validation = walletValidation[input.network];\n  if (validation) {\n    if (!input.walletAddress.startsWith(validation.prefix)) errors.push(`Wallet address for ${input.network} must start with ${validation.prefix}`);\n    if (input.walletAddress.length !== validation.length) errors.push(`Wallet address for ${input.network} must be ${validation.length} characters`);\n  }\n}\n\nreturn [{ json: { ...input, isValid: errors.length === 0, validationErrors: errors, receivedAt: new Date().toISOString() } }];"
      },
      "id": "05-validate-input",
      "name": "05-validate-input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [480, 300]
    },
    {
      "parameters": { "conditions": { "boolean": [{ "value1": "={{ $json.isValid }}", "value2": true }] } },
      "id": "06-validation-gate",
      "name": "06-validation-gate",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [700, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const input = $input.first().json;\nconst RATE_LOCK_DURATION_MS = (Number($env.CRYPTICO_RATE_LOCK_DURATION_SECONDS) || 300) * 1000;\nconst now = Date.now();\nconst lockTimestamp = input.rateLockTimestamp;\nconst lockExpiry = lockTimestamp + RATE_LOCK_DURATION_MS;\nconst isLockValid = now <= lockExpiry;\nconst remainingSeconds = Math.max(0, Math.floor((lockExpiry - now) / 1000));\n\nreturn [{ json: { ...input, rateLockValid: isLockValid, rateLockExpiry: new Date(lockExpiry).toISOString(), rateLockRemainingSeconds: remainingSeconds } }];"
      },
      "id": "10-check-ratelock",
      "name": "10-check-ratelock",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [920, 200]
    },
    {
      "parameters": { "conditions": { "boolean": [{ "value1": "={{ $json.rateLockValid }}", "value2": true }] } },
      "id": "11-ratelock-gate",
      "name": "11-ratelock-gate",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1140, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT * FROM crypto_prices WHERE symbol = '{{ $json.crypto }}' LIMIT 1",
        "options": {}
      },
      "id": "15-fetch-rate",
      "name": "15-fetch-rate",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1360, 100],
      "credentials": { "postgres": { "id": "POSTGRES_CREDENTIAL_ID", "name": "Cryptico PostgreSQL" } }
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const input = $('11-ratelock-gate').first().json;\nconst priceRow = $input.first().json;\n\nreturn [{ json: { ...input, currentRate: priceRow.rate_with_markup, baseRate: priceRow.price_myr, rateUpdatedAt: priceRow.updated_at } }];"
      },
      "id": "16-merge-rate",
      "name": "16-merge-rate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1580, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const input = $input.first().json;\n\nconst NETWORK_FEES = {\n  'TRC-20': Number($env.CRYPTICO_FEE_TRC20) || 1.00,\n  'BEP-20': Number($env.CRYPTICO_FEE_BEP20) || 2.50,\n  'ERC-20': Number($env.CRYPTICO_FEE_ERC20) || 15.00,\n  'POLYGON': Number($env.CRYPTICO_FEE_POLYGON) || 0.50\n};\n\nconst networkFee = NETWORK_FEES[input.network] || 0;\nconst amountAfterFee = input.amountMYR - networkFee;\nconst cryptoAmount = amountAfterFee / input.currentRate;\n\nconst orderId = 'CK' + Date.now().toString(36).toUpperCase() + Math.random().toString(36).substring(2, 5).toUpperCase();\nconst now = new Date().toISOString();\n\nreturn [{ json: {\n  order: {\n    id: orderId,\n    crypto: input.crypto,\n    network: input.network,\n    amount_myr: input.amountMYR,\n    amount_crypto: cryptoAmount,\n    network_fee: networkFee,\n    rate: input.currentRate,\n    base_rate: input.baseRate,\n    customer_name: input.customerName,\n    customer_contact_type: input.contactType,\n    customer_contact: input.contact,\n    wallet_address: input.walletAddress,\n    payment_ref: input.paymentRef || null,\n    has_proof_image: !!input.proofImageBase64,\n    status: 'pending',\n    created_at: now,\n    updated_at: now,\n    kiosk_id: input.kioskId || 'default'\n  },\n  input: input\n} }];"
      },
      "id": "20-generate-order",
      "name": "20-generate-order",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1800, 100]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO orders (id, crypto, network, amount_myr, amount_crypto, network_fee, rate, base_rate, customer_name, customer_contact_type, customer_contact, wallet_address, payment_ref, has_proof_image, status, kiosk_id, created_at, updated_at) VALUES ('{{ $json.order.id }}', '{{ $json.order.crypto }}', '{{ $json.order.network }}', {{ $json.order.amount_myr }}, {{ $json.order.amount_crypto }}, {{ $json.order.network_fee }}, {{ $json.order.rate }}, {{ $json.order.base_rate }}, '{{ $json.order.customer_name }}', '{{ $json.order.customer_contact_type }}', '{{ $json.order.customer_contact }}', '{{ $json.order.wallet_address }}', {{ $json.order.payment_ref ? \"'\" + $json.order.payment_ref + \"'\" : 'NULL' }}, {{ $json.order.has_proof_image }}, '{{ $json.order.status }}', '{{ $json.order.kiosk_id }}', '{{ $json.order.created_at }}', '{{ $json.order.updated_at }}') RETURNING *",
        "options": {}
      },
      "id": "25-insert-order",
      "name": "25-insert-order",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [2020, 100],
      "credentials": { "postgres": { "id": "POSTGRES_CREDENTIAL_ID", "name": "Cryptico PostgreSQL" } }
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const order = $('20-generate-order').first().json.order;\n\nconst CRYPTO_ICONS = { 'USDT': 'üíµ', 'USDC': 'üîµ', 'BNB': 'üü°', 'MATIC': 'üü£' };\nconst formatMYR = (amount) => `RM ${Number(amount).toFixed(2)}`;\nconst formatCrypto = (amount) => Number(amount).toFixed(4);\n\nconst message = `üîî <b>NEW CRYPTO ORDER</b>\\n\\nüìã <b>Order ID:</b> <code>${order.id}</code>\\nüí∞ <b>Amount Paid:</b> ${formatMYR(order.amount_myr)}\\nü™ô <b>Crypto:</b> ${CRYPTO_ICONS[order.crypto] || 'ü™ô'} ${formatCrypto(order.amount_crypto)} ${order.crypto}\\nüìç <b>Network:</b> ${order.network}\\nüí∏ <b>Network Fee:</b> ${formatMYR(order.network_fee)}\\nüìä <b>Rate:</b> 1 ${order.crypto} = ${formatMYR(order.rate)}\\n\\nüë§ <b>Customer:</b>\\n‚îú Name: ${order.customer_name}\\n‚îú ${order.customer_contact_type === 'telegram' ? 'Telegram' : 'Email'}: ${order.customer_contact}\\n‚îî Wallet: <code>${order.wallet_address}</code>\\n\\nüí≥ <b>Payment Ref:</b> ${order.payment_ref || 'Screenshot attached'}\\nüìÖ <b>Time:</b> ${new Date(order.created_at).toLocaleString('en-MY', { dateStyle: 'medium', timeStyle: 'short' })}\\nüèß <b>Kiosk:</b> ${order.kiosk_id}\\n\\n‚è≥ <b>Status:</b> Awaiting verification`;\n\nreturn [{ json: { order: order, telegramMessage: message } }];"
      },
      "id": "30-format-telegram",
      "name": "30-format-telegram",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2240, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.telegram.org/bot{{ $env.CRYPTICO_TELEGRAM_BOT_TOKEN }}/sendMessage",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"chat_id\": \"{{ $env.CRYPTICO_TELEGRAM_CHAT_ID }}\",\n  \"text\": {{ JSON.stringify($json.telegramMessage) }},\n  \"parse_mode\": \"HTML\"\n}",
        "options": { "timeout": 10000 }
      },
      "id": "35-send-telegram",
      "name": "35-send-telegram",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2460, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const order = $json.order;\n\nreturn [{ json: {\n  ok: true,\n  orderId: order.id,\n  status: 'pending',\n  crypto: order.crypto,\n  network: order.network,\n  amountMYR: order.amount_myr,\n  amountCrypto: order.amount_crypto,\n  rate: order.rate,\n  networkFee: order.network_fee,\n  estimatedDelivery: '15-30 minutes after approval',\n  message: `Order ${order.id} submitted successfully. You will be notified when your order is processed.`,\n  trackingUrl: `/order/lookup/${order.id}`\n} }];"
      },
      "id": "55-format-response",
      "name": "55-format-response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2680, 100]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": { "responseCode": 201, "responseHeaders": { "entries": [{ "name": "Content-Type", "value": "application/json" }] } }
      },
      "id": "60-reply-success",
      "name": "60-reply-success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2900, 100]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"ok\": false,\n  \"error_code\": \"VALIDATION_ERROR\",\n  \"message\": \"Request validation failed\",\n  \"errors\": {{ JSON.stringify($json.validationErrors) }}\n}",
        "options": { "responseCode": 400 }
      },
      "id": "99-reply-validation-error",
      "name": "99-reply-validation-error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [920, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"ok\": false,\n  \"error_code\": \"RATE_LOCK_EXPIRED\",\n  \"message\": \"Rate lock has expired. Please restart your transaction.\",\n  \"expiredAt\": \"{{ $json.rateLockExpiry }}\"\n}",
        "options": { "responseCode": 409 }
      },
      "id": "99-reply-ratelock-error",
      "name": "99-reply-ratelock-error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1360, 300]
    }
  ],
  "connections": {
    "01-trigger-webhook": { "main": [[ { "node": "05-validate-input", "type": "main", "index": 0 } ]] },
    "05-validate-input": { "main": [[ { "node": "06-validation-gate", "type": "main", "index": 0 } ]] },
    "06-validation-gate": { "main": [[ { "node": "10-check-ratelock", "type": "main", "index": 0 } ], [ { "node": "99-reply-validation-error", "type": "main", "index": 0 } ]] },
    "10-check-ratelock": { "main": [[ { "node": "11-ratelock-gate", "type": "main", "index": 0 } ]] },
    "11-ratelock-gate": { "main": [[ { "node": "15-fetch-rate", "type": "main", "index": 0 } ], [ { "node": "99-reply-ratelock-error", "type": "main", "index": 0 } ]] },
    "15-fetch-rate": { "main": [[ { "node": "16-merge-rate", "type": "main", "index": 0 } ]] },
    "16-merge-rate": { "main": [[ { "node": "20-generate-order", "type": "main", "index": 0 } ]] },
    "20-generate-order": { "main": [[ { "node": "25-insert-order", "type": "main", "index": 0 } ]] },
    "25-insert-order": { "main": [[ { "node": "30-format-telegram", "type": "main", "index": 0 } ]] },
    "30-format-telegram": { "main": [[ { "node": "35-send-telegram", "type": "main", "index": 0 } ]] },
    "35-send-telegram": { "main": [[ { "node": "55-format-response", "type": "main", "index": 0 } ]] },
    "55-format-response": { "main": [[ { "node": "60-reply-success", "type": "main", "index": 0 } ]] }
  },
  "settings": { "executionOrder": "v1", "saveExecutionProgress": true, "errorWorkflow": "Cryptico-ATM-07-Error-Handler" },
  "tags": [{ "name": "cryptico-atm" }, { "name": "order-submit" }]
}
